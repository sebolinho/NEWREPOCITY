"use strict";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const postcss_selector_parser_1 = __importDefault(require("postcss-selector-parser"));
const minimal_renamer_1 = require("./minimal-renamer");
// eslint-disable-next-line no-redeclare
const plugin = ({ strategy = 'none', by = 'whole', prefix = '', except = [], ids = false, outputMapCallback, } = {}) => {
    const exceptSet = new Set(except);
    return {
        postcssPlugin: 'postcss-rename',
        prepare() {
            if (strategy === 'none' && !outputMapCallback && !prefix)
                return {};
            const outputMap = outputMapCallback
                ? {}
                : null;
            let rename;
            if (strategy === 'none') {
                rename = name => name;
            }
            else if (strategy === 'debug') {
                rename = name => name + '_';
            }
            else if (strategy === 'minimal') {
                const renamer = new minimal_renamer_1.MinimalRenamer(skip);
                rename = name => renamer.rename(name);
            }
            else if (typeof strategy === 'string') {
                throw new Error(`Unknown strategy "${strategy}".`);
            }
            else {
                rename = strategy;
            }
            if (by !== 'whole' && by !== 'part') {
                throw new Error(`Unknown mode "${by}".`);
            }
            function renameNode(node) {
                if (skip(node.value))
                    return;
                if (by === 'part') {
                    node.value =
                        prefix +
                            node.value
                                .split('-')
                                .map(part => {
                                const newPart = skip(part) ? part : rename(part);
                                if (outputMap)
                                    outputMap[part] = newPart;
                                return newPart;
                            })
                                .join('-');
                }
                else {
                    const newName = prefix + rename(node.value);
                    if (outputMap)
                        outputMap[node.value] = newName;
                    node.value = newName;
                }
            }
            function skip(nodeValue) {
                if (exceptSet.has(nodeValue))
                    return true;
                for (const val of exceptSet)
                    if (val instanceof RegExp && val.test(nodeValue))
                        return true;
                return false;
            }
            const selectorProcessor = postcss_selector_parser_1.default(selectors => {
                selectors.walkClasses(renameNode);
                if (ids)
                    selectors.walkIds(renameNode);
            });
            return {
                Rule(ruleNode) {
                    if (ruleNode.parent.type !== 'atrule' ||
                        !ruleNode.parent.name.endsWith('keyframes')) {
                        selectorProcessor.process(ruleNode);
                    }
                },
                OnceExit() {
                    if (outputMapCallback)
                        outputMapCallback(outputMap);
                },
            };
        },
    };
};
module.exports = plugin;
//# sourceMappingURL=index.js.map